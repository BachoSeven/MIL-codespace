import Mathlib.Tactic

--We start with two exercises over ℕ and ℤ
--useful tactics: zify, norm_num
example (n : ℕ) (hn : 0 < n) : (n + 1) ∣ (n^2 + 1) ↔ n = 1 := by
  constructor
  intro h
  have : (n:ℤ)+1 ∣ (n:ℤ)^2-1 := by
    calc
      (n:ℤ)+1 ∣ (n+1)*(n-1) := by
        exact Int.dvd_mul_right _ _
      _ = (n:ℤ)^2 - 1 := by
        ring
  have np2 : (n:ℤ)+1 ∣ 2 := by
    zify at h
    have a1 := Int.dvd_sub h this
    simp at a1
    exact a1
  have asdf := Int.le_of_dvd (by norm_num) np2
  linarith
  intro n1
  rw [n1]
  norm_num

example (x : ℤ) : x - 3 ∣ x^3 - 3 ↔ x - 3 ∣ 24 := by
  constructor
  -- apply euclidean division
  sorry
  intro h
  sorry

variable (R : Type*) [CommRing R]

#check (0:R)
#check (1:R)


example : (2 * 1 : R) = 1 + 1 := by
  --exact two_mul 1
  ring

example (x y : R) : (x + y)^2 = x^2 + y^2 + 2*x*y := by ring

--even over a SemiRing, the ring tactic works!
example (x y : ℕ) : (x + y)^2 = x^2 + y^2 + 2*x*y := by ring

--to denote units of a ring we use the notation Rˣ (\^x)
example (x : ℤˣ) : x = 1 ∨ x = -1 := by
  exact Int.units_eq_one_or x

--this is a ring homomorphism
example {R S : Type*} [Ring R] [Ring S] (f : R →+* S) (x y : R) :
    f (x + y) = f x + f y := by
    -- alternativo a `exact RingHom.map_add f x y`
    exact f.map_add x y

example {R S : Type*} [Ring R] [Ring S] (f : R →+* S) : Rˣ →* Sˣ := by
  exact Units.map f

#check Ideal
-- A (left) ideal in a semiring `R` is an additive submonoid `s` such that
--`a * b ∈ s` whenever `b ∈ s`. If `R` is a ring, then `s` is an additive subgroup.

variable (I : Ideal R)

#check I

example : (0 : R) ∈ I := Ideal.zero_mem I

example (a b : R) : a ∈ I → b ∈ I → a + b ∈ I := Ideal.add_mem I

example (a b : R) : b ∈ I → a * b ∈ I := Ideal.mul_mem_left I a

example (a b : R) : b ∈ I → a * b ∈ I := Submodule.smul_mem I a

--this is theorem: unit_mul_mem_iff_mem
example {x y : R} (hy : IsUnit y) : y * x ∈ I ↔ x ∈ I := by
  sorry


--Ideal.span S is the ideal generated by a given set S
#check Ideal.span (∅ : Set R)

example : Ideal.span (∅ : Set R) = ⊥ := Ideal.span_empty

example (s t : Set R) : Ideal.span (s ∪ t) = Ideal.span s ⊔ Ideal.span t := Ideal.span_union s t

--some theorems have the Ideal namespace, but most come from Subodule. Let's just open both.
open Ideal Submodule

#check Ideal.span {2,3}
#check span {2,3}
#check span {(2 : ℤ), (3 : ℤ)}
#check mem_top
#check add_mem

--we can use "ext x" to start proofs of equalities of two ideals.

example : span {(2 : ℤ), (3 : ℤ)} = span {(1:ℤ)} := by
  sorry

/-!
# Adjoining a root of a quadratic polynomial

## Main definitions

`quad_ring F a b` is the ring `F[α]`, where `α` is a root of the polynomial `X^2 - aX - b`.

To construct elements of `quad_ring F a b`:
 * the coercion `(↑(r : F) : quad_ring F a b)` sends `r` to `r + 0 α`
 * `quad_ring.root F a b` corresponds to `0 + 1 α`
 * `quad_ring` has a `comm_ring` instance providing `0`, `1`, `+`, `*`, and `-`

## Main results (these are the results we proved)

 * `quad_ring.comm_ring`: `quad_ring F a b` is a commutative ring if `F` is
 * `quad_ring.field`: `quad_ring F 0 b` is a field if `F` is and `b` is not a square
 * `quad_ring.power_basis`: shows `quad_ring F a b` is generated by adjoining `root F a b`

 * `quad_ring.map`: lift a ring homomorphism `R → S` to a ring homomorphism `R[α] → S[α]`
 * `quad_ring.congr`: lift a ring isomorphism `R ≃ S` to a ring isomorphism `R[α] ≃ S[α]`
 * `quad_ring.lift`: lift a ring homomorphism `R → S` to a ring homomorphism `R[α] → S`,
   given a suitable image for `α`

 * `quad_ring.algebra''` (requires `open_locale quad_ring`): lift an `R`-algebra on `S`
   to a `quad_ring R a b`-algebra on `quad_ring S a' b'`, given that `a b` map to `a' b'`.
   Note that we only require `a' b' : S` to be the image propositionally (not just definitionally),
   this allows easy use of numerals, e.g. `quad_ring ℤ 0 (-5)` and `quad_ring ℚ 0 (-5)`
   (otherwise we'd have `quad_ring ℚ (↑0) (↑-5)`).

 * `quad_ring.norm_eq`: the norm of `⟨a, b⟩ : quad_ring R 0 d` is `a^2 - d * b^2`
   (see also `algebra.norm`)

 * `quad_ring.is_integral_closure_23`,
   `quad_ring.is_integral_closure_1`: together specify the ring of integers of
   `ℚ(√d)` (where `d` is squarefree, of course)

-/
--let's create this structure!
@[ext]
structure quad_ring (F : Type*) (a b : F) :=
  (b1 : F)
  (b2 : F)

--in quad_ring F a b, with basis {1,α}, b1 is the coefficient of 1 and b2 is the coefficient of α.

namespace quad_ring
variable (F: Type*) [CommRing F] (a b : F)

@[simp] theorem eta : ∀ z : quad_ring F a b, (⟨z.b1,z.b2⟩ : quad_ring F a b) = z := fun _ ↦ rfl

/-!
### Basic constructions of elements in `quad_ring R a b`
-/


/- The standard inclusion `F → quad_ring F a b`. -/
instance : Coe F (quad_ring F a b) where coe z := ⟨z,0⟩


@[simp] lemma coe_b1 (r : F) :(r : quad_ring F a b).b1 = r := rfl

@[simp] lemma coe_b2 (r : F) : (r : quad_ring F a b).b2 = 0 := rfl

@[simp] theorem coe_inj {z w : F} : (z : quad_ring F a b) = w ↔ z = w := by
  sorry

lemma coe_injective : Function.Injective (Coe.coe : F → quad_ring F a b) := by
  sorry


/-- `quad_ring.root F a b` is the adjoined root `α` of the polynomial `x^2 - ax - b`. -/
def root : quad_ring F a b := ⟨0, 1⟩

@[simp] lemma root_b1 : (root F a b).b1 = 0 := rfl
@[simp] lemma root_b2 : (root F a b).b2 = 1 := rfl

/-!
### Ring stucture on `quad_ring R a b`
-/

instance : Zero (quad_ring F a b) := ⟨(0 : F)⟩
instance : Inhabited (quad_ring F a b) := ⟨0⟩

@[simp] lemma zero_b1 : (0 : quad_ring F a b).b1 = 0 := rfl
@[simp] lemma zero_b2 : (0 : quad_ring F a b).b2 = 0 := rfl

@[simp] lemma coe_zero : ((0 : F) : quad_ring F a b) = 0 := rfl

@[simp] theorem coe_eq_zero {z : F} : (z : quad_ring F a b) = 0 ↔ z = 0 :=
coe_inj F a b

instance : One (quad_ring F a b) := ⟨(1 : F)⟩

@[simp] lemma one_b1 : (1 : quad_ring F a b).b1 = 1 := rfl
@[simp] lemma one_b2 : (1 : quad_ring F a b).b2 = 0 := rfl

@[simp] lemma coe_one : ((1 : F) : quad_ring F a b) = 1 := rfl

instance : Add (quad_ring F a b) where add z w := ⟨z.b1 + w.b1, z.b2 + w.b2⟩

@[simp] lemma add_b1 (z w : quad_ring F a b) : (z + w).b1 = z.b1 + w.b1 := rfl
@[simp] lemma add_b2 (z w : quad_ring F a b) : (z + w).b2 = z.b2 + w.b2 := rfl

@[simp] lemma coe_add (r s : F) : ((r + s : F) : quad_ring F a b) = r + s := by
  ext
  simp
  simp

instance : Neg (quad_ring F a b) where neg z := ⟨-(z.b1), -(z.b2)⟩

@[simp] lemma neg_b1 (z : quad_ring F a b) : (-z).b1 = -z.b1 := rfl
@[simp] lemma neg_b2 (z : quad_ring F a b) : (-z).b2 = -z.b2 := rfl

@[simp] lemma coe_neg (n : F) : (↑(-n) : quad_ring F a b) = - ↑n := by
  ext
  simp
  simp

instance : Sub (quad_ring F a b) where sub z w := ⟨z.b1 - w.b1, z.b2 - w.b2⟩

@[simp] lemma sub_b1 (z w : quad_ring F a b) : (z - w).b1 = z.b1 - w.b1 := rfl
@[simp] lemma sub_b2 (z w : quad_ring F a b) : (z - w).b2 = z.b2 - w.b2 := rfl

@[simp] lemma coe_sub (z w : F) : (↑(z - w) : quad_ring F a b) = ↑z - ↑w := by
  ext
  simp
  simp

variable (R : Type*) [Monoid R] [SMul R F] (c : R) --[SMul ℕ F] [SMul ℤ F]

/-- This scalar multiplication is used to define `nsmul`, `zsmul`. -/
instance : SMul R (quad_ring F a b) where smul c x := ⟨c • x.b1, c • x.b2⟩

@[simp] lemma smul_b1 (z : quad_ring F a b) : (c • z).b1 = c • z.b1 := rfl
@[simp] lemma smul_b2 (z : quad_ring F a b) : (c • z).b2 = c • z.b2 := rfl

instance : Mul (quad_ring F a b) where mul z w := ⟨z.b1 * w.b1 + z.b2 * w.b2 * b ,z.b2 * w.b1 + z.b1 * w.b2 + z.b2 * w.b2 * a⟩

@[simp] lemma mul_b1 (z w : quad_ring F a b) :
  (z * w).b1 = z.b1 * w.b1 + z.b2 * w.b2 * b := rfl
@[simp] lemma mul_b2 (z w : quad_ring F a b) :
  (z * w).b2 = z.b2 * w.b1 + z.b1 * w.b2 + z.b2 * w.b2 * a := rfl

--we can do some computations, like computing z^2. Only, we don't have powers yet (in quad_ring F a b), so we need to write z*z instead of z^2.
lemma square_of (z : quad_ring F a b) : z*z = ⟨z.1^2 + z.2^2 * b, 2 * z.1 * z.2 + z.2^2 * a⟩ := by
  sorry



#check CommRing

--with some of the stuff we already have and a bit more patience we can prove the following instance.

lemma quad_ring_add_assoc : ∀ (a_1 b_1 c : quad_ring F a b), a_1 + b_1 + c = a_1 + (b_1 + c) := sorry

def quad_ring_npow :  ℕ → quad_ring F a b → quad_ring F a b
  | 0 => sorry
  | n + 1 => sorry

--can you continue?

instance : CommRing (quad_ring F a b) where
  add := Add.add
  add_assoc := quad_ring_add_assoc _ _ _
  zero := Zero.zero
  zero_add := sorry
  add_zero := sorry
  nsmul := SMul.smul
  nsmul_zero := sorry
  nsmul_succ := sorry
  add_comm := sorry
  mul := sorry
  left_distrib := sorry
  right_distrib := sorry
  zero_mul := sorry
  mul_zero := sorry
  mul_assoc := sorry
  one := sorry
  one_mul := sorry
  mul_one := sorry
  natCast := fun n ↦ sorry
  natCast_zero := sorry
  natCast_succ := sorry
  npow := quad_ring_npow _ _ _
  npow_zero := sorry
  npow_succ := sorry
  neg := sorry
  sub := sorry
  sub_eq_add_neg := sorry
  zsmul := sorry
  zsmul_zero' := sorry
  zsmul_succ' := sorry --CAREFUL: using • works much better than using SMul.smul n x
  zsmul_neg' := sorry
  add_left_neg := sorry
  intCast := sorry
  intCast_ofNat := sorry
  intCast_negSucc := sorry
  mul_comm := sorry


end quad_ring
